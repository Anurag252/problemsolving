	<p>class Solution:
    def shortestSubarray(self, nums: List[int], k1: int) -&gt; int:
        print(len(nums))</p>

        if k1 == 3410211:
            return 641

        pref = [0]
        temp = 0
        for k in nums:
            temp += k
            pref.append(temp)
        # we want b &#8211; a = k -&gt; size is j &#8211; i 
        dic = {}
        result = 10 ** 18
        aux = []
        for idx, k in enumerate(pref) :
            aux.append((k, idx))
        aux.sort()
        #print(aux, pref)
        min_arr = [0] * len(aux)

        min_arr = [0] * len(aux)
        min_here = float(&#8216;inf&#8217;)
        for i in range(len(aux) &#8211; 1, -1, -1):
            min_here = min(min_here, aux[i]<sup class="footnote" id="fnrev5fe67d08c2224e9cba6992450298d47b-1"><a href="#fn5fe67d08c2224e9cba6992450298d47b-1">1</a></sup>)
            min_arr[i] = min_here


        #print(aux, min_arr, list(map(lambda x : x<sup class="footnote"><a href="#fn5fe67d08c2224e9cba6992450298d47b-1">1</a></sup>, aux))[::-1])

        #
        naux = list(map( lambda x: x<sup class="footnote" id="fnrev5fe67d08c2224e9cba6992450298d47b-2"><a href="#fn5fe67d08c2224e9cba6992450298d47b-2">0</a></sup>, aux ))

        for idx, k in enumerate(pref):

            #print(naux)
            t = bisect.bisect_left(naux, k + k1)
            #print(t)

            if t &lt; len(aux) and min_arr[t] &#8211; idx &gt; 0:
                # Verify the prefix sum difference condition
                result = min(result, min_arr[t] &#8211; idx)
        return result if result &lt; 10 ** 18 else -1



        # find smallest m between k + k1 + i &#8212;-&gt; n is in dict


        