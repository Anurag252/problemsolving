	<p>int maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int minutes) {
    if (customersSize == 0) {
        return 0;
    }</p>

    // Initialize prefix and suffix sums
    int prefix_sum[customersSize];
    int suffix_sum[customersSize];

    // Calculate prefix sum
    prefix_sum<sup class="footnote" id="fnrevd4c62768a46b4a02bd328d82a722951c-1"><a href="#fnd4c62768a46b4a02bd328d82a722951c-1">0</a></sup> = grumpy<sup class="footnote"><a href="#fnd4c62768a46b4a02bd328d82a722951c-1">0</a></sup>  0 ? customers[0] : 0;
    for (int i = 1; i < customersSize; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + (grumpy[i]  0 ? customers[i] : 0);
    }

    // Calculate suffix sum
    suffix_sum[customersSize &#8211; 1] = grumpy[customersSize &#8211; 1]  0 ? customers[customersSize - 1] : 0;
    for (int i = customersSize - 2; i >= 0; i--) {
        suffix_sum[i] = suffix_sum[i + 1] + (grumpy[i]  0 ? customers[i] : 0);
    }

    // Calculate the maximum additional satisfaction using the sliding window technique
    int maxAdditionalSatisfied = 0;
    for (int i = 0; i <= customersSize &#8211; minutes; i++) {
        int sum = 0;
        for (int j = i; j < i + minutes; j++) {
            sum += customers[j];
        }

        // Calculate the current satisfaction including the window
        int currentSatisfaction = (i > 0 ? prefix_sum[i &#8211; 1] : 0) + sum + (i + minutes < customersSize ? suffix_sum[i + minutes] : 0);
        if (currentSatisfaction > maxAdditionalSatisfied) {
            maxAdditionalSatisfied = currentSatisfaction;
        }
    }

    return maxAdditionalSatisfied;
}