	<p>class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -&gt; int:
        # maximize the value and minimize the gap
        # closest one and has largest value preferably/not necessarily larger than itself
        st = []</p>

        addn = []

        subs = []

        pref_sum = [0] * len(values) 

        temp = -10 ** 8
        for idx, k in enumerate(values):
            addn.append(k + idx)

        for idx, k in enumerate(values):
            subs.append(k &#8211; idx)
        #print(subs)

        for idx, k in enumerate(subs[::-1]):
            if k &gt; temp:
                temp = k
                #print(len(subs) &#8211; 1 &#8211; idx)
            pref_sum[len(subs) &#8211; 1 &#8211; idx] = temp
        #print(pref_sum, subs, addn)

        s = 0
        for idx, k in enumerate(addn):
            if idx + 1 &lt; len(pref_sum) and k + pref_sum[idx+1] &gt; s:
                s = k + pref_sum[idx+1]
        return s



        &#8220;&#8221;&#8220;
        [(0,8), (1,1), (2,5), (3,2), (4,6)]
         [8, 2, 7, 5, 10]
        =[8, 0, 3, -1, 2]

        [8, ]
        &#8220;&#8221;&#8220;