	<p>class Solution:
    def maximumLength(self, nums: List[int], k: int) -&gt; int:
        &#8220;&#8221;&#8220;
        T[n] = max(T[n-i] + 1)  if (a[i] + a[n-i]) % k == v[n-i]</p>

        we can use map somehow to find condition in above statement
        say a number a[i] % k = l
        and in map we need to find v[n-i] &#8211; l version.
        The problem arises that we still need to scan twice


        another approach is reduce all by dividing with k so evenry number is &lt; k
        now if a[i] and a[j]  will have remainder as a[i] + a[j]

        basically since k &lt; 1000, take ana rray of size 1000, and at event element store the size ,
        another array to store the original a[i] % k, now loop over all and find out  largest[orig[i] + curr % k] value so that it is max. 


        we need to store the end index of subsequence in original[i] where i is the sum module we are trying to create , 
        then loop over all m in nums
        and for each m , loop over original and find index such that i = (m1 + nums[original[i]])% k
        if yes then original[i] = this index
        and len also inc by 1
        &#8220;&#8221;&#8220;


        # lets try dp first T[n] = max(T[n-i] + 1)  if (a[i] + a[n-i]) % k == v[n-i] 
        # here v[n-i] also needs updation which is problamatic
        # it stores that at index n-i, the value of the running mod , 
        # we see that single dp is not sufficinet bcoz a,b &#8230;.c here c can form multiple mod sums
        # and we must compare all mod sums &#8211; a + c, b + c &#8230;
        # so we store T[i][mod] = max(T[j][mod]) max value



        T = [[0 for _ in range(k)] for _ in range(len(nums))]

        count = 1  # every number is a valid subsequence of length 1

        for i in range(len(nums)):
            for j in range(i):
                mod = (nums[i] + nums[j]) % k
                if T[j][mod] &gt; 0:
                    T[i][mod] = max(T[i][mod], T[j][mod] + 1)
                else:
                    T[i][mod] = max(T[i][mod], 2)  # first valid pair
            count = max(count, max(T[i]))

        return count


        original = [(-1,0)] * k

        for j, m in enumerate(nums):
            original[m%k] = (j if original[m%k]<sup class="footnote" id="fnreve9dee058fd6e46ed86c8f285110fcc12-1"><a href="#fne9dee058fd6e46ed86c8f285110fcc12-1">0</a></sup>  -1 else original[m%k][0], 1 if original[m%k][1]  0 else original[m%k]<sup class="footnote" id="fnreve9dee058fd6e46ed86c8f285110fcc12-2"><a href="#fne9dee058fd6e46ed86c8f285110fcc12-2">1</a></sup>)

        for j, m in enumerate(nums):
            for i, n in enumerate(original):
                if (m % k + nums[original[i]<sup class="footnote"><a href="#fne9dee058fd6e46ed86c8f285110fcc12-1">0</a></sup>] % k) % k == i: # we have a match
                    print(&#8220;here&#8221;)
                    original[i] = (j , original[i]<sup class="footnote"><a href="#fne9dee058fd6e46ed86c8f285110fcc12-2">1</a></sup> + 1)
        result = 0
        print(original)
        for (m,n) in original:
            result = max(result, n)
        return result