	<p>class Solution:
    def destroyTargets(self, nums: List[int], space: int) -&gt; int:
        remainder_count = {}
        # Dictionary to store minimum number for each remainder
        min_number = {}</p>

        # Group numbers by remainder and track minimum in each group
        for num in nums:
            r = num % space
            remainder_count&#174; = remainder_count.get(r, 0) + 1
            min_number&#174; = min(min_number.get(r, float(&#8216;inf&#8217;)), num)

        max_targets = max(remainder_count.values())
        min_seed = float(&#8216;inf&#8217;)

        # Find minimum seed that can destroy maximum targets
        for r in remainder_count:
            if remainder_count&#174; == max_targets:
                min_seed = min(min_seed, min_number&#174;)

        return min_seed