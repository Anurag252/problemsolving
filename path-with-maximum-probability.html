	<p>class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -&gt; float:
        matrix = {}
        result = {}</p>

        # Build the adjacency list
        for k, l in zip(edges, succProb):
            if k<sup class="footnote" id="fnrev52cf457ee7904d6cbb155869e1c2a839-1"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup> not in matrix:
                matrix[k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>] = [(k<sup class="footnote" id="fnrev52cf457ee7904d6cbb155869e1c2a839-2"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>, l)]
            else:
                matrix[k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>].append((k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>, l))

            if k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup> not in matrix:
                matrix[k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>] = [(k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>, l)]
            else:
                matrix[k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>].append((k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>, l))

        visited = set()
        global q  # Declare q as a global variable
        q = [(-1, start_node)]  # Initialize max-heap with negative probabilities
        result[start_node] = 1  # Probability of start_node is 1

        def test():
            global q  # Declare q as global inside the function to use the global variable
            while len(q) &gt; 0:
                t = heapq.heappop(q)

                # Convert back the probability to positive
                current_prob = -t<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>
                current_node = t<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>

                # If we&#8217;ve reached the end node, return the probability
                if current_node == end_node:
                    return current_prob

                if current_node in visited:
                    continue

                visited.add(current_node)

                if current_node not in matrix:
                    continue

                for k in matrix[current_node]:
                    new_prob = current_prob * k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-2">1</a></sup>
                    if new_prob &gt; result.get(k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>, 0):
                        result[k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>] = new_prob
                        heapq.heappush(q, (-new_prob, k<sup class="footnote"><a href="#fn52cf457ee7904d6cbb155869e1c2a839-1">0</a></sup>))  # Push with negative probability to maintain max-heap

            return 0  # Return 0 if end_node is not reachable

        # Call the helper function and return its result
        return test()   