	<p>class Trie:
    def __init__(self):
        self.dict = {}</p>

    def traverse_recurse(self, root, s):
        if len(s) == 0:
            return
        if s<sup class="footnote" id="fnrevfea8bc38b9764cd4b5e39d11f29b1a84-1"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup> in root:
                self.traverse_recurse(root[s<sup class="footnote"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup>], s[1:])
        else:
            root[s<sup class="footnote"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup>] = {}
            self.traverse_recurse(root[s<sup class="footnote"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup>], s[1:])

    def traverse(self, root, s) -&gt; bool:
        if len(s) == 0:
            return True
        if s<sup class="footnote"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup> in root:
            return self.traverse(root[s<sup class="footnote"><a href="#fnfea8bc38b9764cd4b5e39d11f29b1a84-1">0</a></sup>], s[1:])
        else:
            return False

    def insert(self, s):
        root = self.dict
        self.traverse_recurse(root, s)

    def contains(self, s) -&gt; bool:
        root = self.dict
        return self.traverse(root, s)





	<p>class Solution:
    def stringMatching(self, words: List[str]) -&gt; List[str]:</p>

        t = Trie()

        words.sort(key = lambda x: -len(x))
        res = []
        for k in words:
            if t.contains(k):
                res.append(k)
            for i in range(0, len(k)):
                t.insert(k[i:])
        return res
        