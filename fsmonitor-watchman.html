	<p>#!/usr/bin/perl</p>

	<p>use strict;<br />
use warnings;<br />
use <span class="caps">IPC</span>::Open2;</p>

	<p>	<ol>
		<li>An example hook script to integrate Watchman</li>
		<li>(https://facebook.github.io/watchman/) with git to speed up detecting</li>
		<li>new and modified files.</li>
	</ol>
#
	<ol>
		<li>The hook is passed a version (currently 2) and last update token</li>
		<li>formatted as a string and outputs to stdout a new update token and</li>
		<li>all files that have been modified since the update token. Paths must</li>
		<li>be relative to the root of the working tree and separated by a single <span class="caps">NUL</span>.</li>
	</ol>
#
	<ol>
		<li>To enable this hook, rename this file to &#8220;query-watchman&#8221; and set</li>
		<li>&#8217;git config core.fsmonitor .git/hooks/query-watchman&#8217;</li>
	</ol>
#<br />
my ($version, $last_update_token) = @ARGV;</p>

	<ol>
		<li>Uncomment for debugging</li>
		<li>print <span class="caps">STDERR</span> &#8220;$0 $version $last_update_token\n&#8221;;</li>
	</ol>

	<ol>
		<li>Check the hook interface version<br />
if ($version ne 2) {
	die &#8220;Unsupported query-fsmonitor hook version &#8216;$version&#8217;.\n&#8221; .
	    &#8220;Falling back to scanning&#8230;\n&#8221;;<br />
}</li>
	</ol>

	<p>my $git_work_tree = get_working_dir();</p>

	<p>my $retry = 1;</p>

	<p>my $json_pkg;<br />
eval {
	require <span class="caps">JSON</span>::XS;
	$json_pkg = &#8220;<span class="caps">JSON</span>::XS&#8221;;
	1;<br />
} or do {
	require <span class="caps">JSON</span>::PP;
	$json_pkg = &#8220;<span class="caps">JSON</span>::PP&#8221;;<br />
};</p>

	<p>launch_watchman();</p>

	<p>sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}<br />
}</p>

	<p>sub output_result {
	my ($clockid, <code>files) = </code>_;</p>

	<p>	# Uncomment for debugging watchman output
	# open (my $fh, &#8220;>&#8221;, &#8220;.git/watchman-output.out<a href="utf8">);
	# binmode $fh,</a>&#8221;;
	# print $fh &#8220;$clockid\n@files\n&#8221;;
	# close $fh;</p>

	<p>	binmode <span class="caps">STDOUT</span>, &#8220;:utf8&#8221;;
	print $clockid;
	print &#8220;\0&#8221;;
	local $, = &#8220;\0&#8221;;
	print @files;<br />
}</p>

	<p>sub watchman_clock {
	my $response = qx/watchman clock &#8220;$git_work_tree&#8221;/;
	die &#8220;Failed to get clock id on &#8216;$git_work_tree&#8217;.\n&#8221; .
		&#8220;Falling back to scanning&#8230;\n&#8221; if $? != 0;</p>

	<p>	return $json_pkg->new->utf8->decode($response);<br />
}</p>

	<p>sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, &#8216;watchman -j &#8212;no-pretty&#8217;)
	or die &#8220;open2() failed: $!\n&#8221; .
	&#8220;Falling back to scanning&#8230;\n&#8221;;</p>

	<p>	# In the query expression below we&#8217;re asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we&#8217;re using the &#8220;since&#8221; generator to use the
	# recency index to select candidate nodes and &#8220;fields&#8221; to limit the
	# output to file names only. Then we&#8217;re using the &#8220;expression&#8221; term to
	# further constrain the results.
	my $last_update_line = &#8220;&#8221;;
	if (substr($last_update_token, 0, 1) eq &#8220;c&#8221;) {
		$last_update_token = &#8220;\&#8221;$last_update_token\&#8221;&#8220;;
		$last_update_line = qq[\n&#8220;since&#8221;: $last_update_token,];
	}
	my $query = <<&#8220;	END&#8221;;
		[&#8220;query&#8221;, &#8220;$git_work_tree&#8221;, {$last_update_line
			&#8220;fields&#8221;: [&#8220;name&#8221;],
			&#8220;expression&#8221;: [&#8220;not&#8221;, [&#8220;dirname&#8221;, &#8220;.git&#8221;]]
		}]
	END</p>

	<p>	# Uncomment for debugging the watchman query
	# open (my $fh, &#8220;>&#8221;, &#8220;.git/watchman-query.json&#8221;);
	# print $fh $query;
	# close $fh;</p>

	<p>	print <span class="caps">CHLD</span>_IN $query;
	close <span class="caps">CHLD</span>_IN;
	my $response = do {local $/; <CHLD_OUT>};</p>

	<p>	# Uncomment for debugging the watch response
	# open ($fh, &#8220;>&#8221;, &#8220;.git/watchman-response.json&#8221;);
	# print $fh $response;
	# close $fh;</p>

	<p>	die &#8220;Watchman: command returned no output.\n&#8221; .
	&#8220;Falling back to scanning&#8230;\n&#8221; if $response eq &#8220;&#8221;;
	die &#8220;Watchman: command returned invalid output: $response\n&#8221; .
	&#8220;Falling back to scanning&#8230;\n&#8221; unless $response =~ /^\{/;</p>

	<p>	return $json_pkg->new->utf8->decode($response);<br />
}</p>

	<p>sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry&#8212;;
		my $response = qx/watchman watch &#8220;$git_work_tree&#8221;/;
		die &#8220;Failed to make watchman watch &#8216;$git_work_tree&#8217;.\n&#8221; .
		    &#8220;Falling back to scanning&#8230;\n&#8221; if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die &#8220;Watchman: $error.\n&#8221; .
		&#8220;Falling back to scanning&#8230;\n&#8221; if $error;</p>

	<p>		# Uncomment for debugging watchman output
		# open (my $fh, &#8220;>&#8221;, &#8220;.git/watchman-output.out&#8221;);
		# close $fh;</p>

	<p>		# Watchman will always return all files on the first query so
		# return the fast &#8220;everything is dirty&#8221; flag to git and do the
		# Watchman query just to get it over with now so we won&#8217;t pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};</p>

	<p>		die &#8220;Watchman: $error.\n&#8221; .
		&#8220;Falling back to scanning&#8230;\n&#8221; if $error;</p>

	<p>		output_result($o->{clock}, (&#8220;/&#8221;));
		$last_update_token = $o->{clock};</p>

	<p>		eval { launch_watchman() };
		return 0;
	}</p>

	<p>	die &#8220;Watchman: $error.\n&#8221; .
	&#8220;Falling back to scanning&#8230;\n&#8221; if $error;</p>

	<p>	return 1;<br />
}</p>

	<p>sub get_working_dir {
	my $working_dir;
	if ($^O =~ &#8216;msys&#8217; || $^O =~ &#8216;cygwin&#8217;) {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}</p>

	<p>	return $working_dir;<br />
}</p>