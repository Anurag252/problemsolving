	<ol>
		<li>Definition for a binary tree node.</li>
		<li>class TreeNode:</li>
		<li>def __init__(self, x):</li>
		<li>self.val = x</li>
		<li>self.left = None</li>
		<li>self.right = None</li>
	</ol>

	<p>class Codec:
    #l = 2*i + 1
    #r = 2*i + 2
    def __init__(self):
        self.inord = &#8220;&#8220;
        self.preord = &#8220;&#8221;</p>

    def preorder(self, root: [TreeNode]) -&gt; str:
        if root != None and root.left  None and root.right  None:
            return  str(root.val)
        if root == None:
            return &#8220;&#8221;

        m = str(root.val)
        l = self.preorder(root.left)
        r = self.preorder(root.right)
        return &#8220;,&#8221;.join(filter(None,[m,l,r]))


    def inorder(self, root: [TreeNode]) -&gt; str:
        if root != None and root.left  None and root.right  None:
            return  str(root.val)
        if root == None:
            return &#8220;&#8221;

        l = self.inorder(root.left)
        m = str(root.val)
        r = self.inorder(root.right)

        return &#8220;,&#8221;.join(filter(None,[l,m,r]))



    def serialize(self, root: Optional[TreeNode]) -&gt; str:
        &#8220;&#8221;&#8220;Encodes a tree to a single string.
        &#8220;&#8221;&#8220;
        self.inord= self.inorder(root)
        self.preord = self.preorder(root)
        return self.inord + &#8220;#&#8221; + self.preord





    def deserialize(self, data: str, index : int = 0) -&gt; Optional[TreeNode]:
        &#8220;&#8221;&#8220;Decodes your encoded data to tree.
        &#8220;&#8221;&#8220;
        #print(data)
        arr = data.split(&#8220;#&#8221;)

        inorder = arr<sup class="footnote" id="fnrev056b5b7bd831498f9b87199d8d7e06ff-1"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>
        preorder = arr<sup class="footnote" id="fnrev056b5b7bd831498f9b87199d8d7e06ff-2"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-2">1</a></sup>
        return self.build_tree(inorder, preorder)

    def build_tree(self, inorder: str, preorder: str) -&gt; TreeNode:
        if len(inorder)  0 and len(preorder)  0:
            return None
        inord = inorder.split(&#8216;,&#8217;)
        preord = preorder.split(&#8216;,&#8217;)
        root = TreeNode(preord<sup class="footnote"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>)
        left_inorder = filter(lambda a: int(a) &lt; int(preord<sup class="footnote"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>), inord)
        right_inorder = filter(lambda a: int(a) &gt; int(preord<sup class="footnote"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>), inord)

        left_preorder = filter(lambda a: int(a) &lt; int(preord<sup class="footnote"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>), preord)
        right_preorder = filter(lambda a: int(a) &gt; int(preord<sup class="footnote"><a href="#fn056b5b7bd831498f9b87199d8d7e06ff-1">0</a></sup>), preord)

        #print(left_inorder, right_inorder, left_preorder, right_preorder)

        root.left = self.build_tree(&#8220;,&#8221;.join(filter(None,left_inorder)), &#8220;,&#8221;.join(filter(None, left_preorder)))
        root.right = self.build_tree(&#8220;,&#8221;.join(filter(None, right_inorder)), &#8220;,&#8221;.join(filter(None, right_preorder)))
        return root







	<ol>
		<li>Your Codec object will be instantiated and called as such:</li>
		<li>Your Codec object will be instantiated and called as such:</li>
		<li>ser = Codec()</li>
		<li>deser = Codec()</li>
		<li>tree = ser.serialize(root)</li>
		<li>ans = deser.deserialize(tree)</li>
		<li>return ans</li>
	</ol>