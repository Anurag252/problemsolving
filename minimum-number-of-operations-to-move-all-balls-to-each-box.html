	<p>class Solution:
    def minOperations(self, boxes: str) -&gt; List[int]:
        &#8220;&#8221;&#8220;
        [. . . . . x . . . .]
        to calculate the number of moves , you must know where are 1s in arr and how far 
        let&#8217;s say 1, 3 
        x-1, x-3 is the dist 
        similarly in revrse arr n-x-1th elem find 1s and their sum
        x1 . x2 . x3 . x4 . x4 .. xn
        xn &#8211; x1 + xn &#8211; x2 + xn- x3 ..
        nXn &#8211; (x1+x2+x3)</p>

        &#8220;&#8221;&#8220;
        pref = []
        suff = []
        temp = 0
        count = 0
        for idx, k in enumerate(boxes):
            if k == <a href="">1</a>
                temp += idx
                count += 1
            pref.append((temp, count))

        temp = 0
        count = 0
        for idx, k in enumerate(boxes[::-1]):
            if k == <a href="">1</a>
                temp += idx
                count += 1
            suff.append((temp, count))
        res = []
        for idx, k in enumerate(pref):
            left  =  k<sup class="footnote" id="fnrevfb7eca9528e74647a6f9db216a0d1ae7-1"><a href="#fnfb7eca9528e74647a6f9db216a0d1ae7-1">1</a></sup> * idx &#8211; k<sup class="footnote" id="fnrevfb7eca9528e74647a6f9db216a0d1ae7-2"><a href="#fnfb7eca9528e74647a6f9db216a0d1ae7-2">0</a></sup>
            right_idx = len(pref) &#8211; 1 &#8211; idx
            right = suff[right_idx]<sup class="footnote"><a href="#fnfb7eca9528e74647a6f9db216a0d1ae7-1">1</a></sup> * right_idx &#8211; suff[right_idx]<sup class="footnote"><a href="#fnfb7eca9528e74647a6f9db216a0d1ae7-2">0</a></sup>
            res.append(left + right)
        return res
        &#8220;&#8221;&#8220;
        print(pref, suff)
        2*1 &#8211; 1 + 1-1
        2*2-1 + 0
        count * idx &#8211; sum
        &#8220;&#8221;&#8220;






        