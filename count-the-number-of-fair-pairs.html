	<p>class Solution:
    def lower_bound(self, nums, low, high, element):
        while low &lt;= high:
            mid = low + ((high &#8211; low) // 2)
            if nums[mid] &gt;= element:
                high = mid &#8211; 1
            else:
                low = mid + 1
        return low</p>

    def countFairPairs(self, nums, lower, upper):
        nums.sort()
        ans = 0
        for i in range(len(nums)):
            # Assume we have picked nums[i] as the first pair element.

            # `low` indicates the number of possible pairs with sum &lt; lower.
            low = self.lower_bound(nums, i + 1, len(nums) &#8211; 1, lower &#8211; nums[i])

            # `high` indicates the number of possible pairs with sum &lt;= upper.
            high = self.lower_bound(
                nums, i + 1, len(nums) &#8211; 1, upper &#8211; nums[i] + 1
            )

            # Their difference gives the number of elements with sum in the
            # given range.
            ans += high &#8211; low

        return ans