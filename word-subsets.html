	<p>class Node:
    def __init__(self):
        self.ls = []
        self.dt = {}</p>

    def print1(self):
        print(self.dt.values(), self.ls)


	<p>class Tree:
    def __init__(self):
        self.root = Node()</p>


    def insert_traverse(self, root, s, id):
        if len(s) == 0:
            return
        for k in s:
            if k not in root.dt:
                root.dt[k] = (set(), Node())
                root.dt[k]<sup class="footnote" id="fnrev3daab284fc314f7382c115a8dd8e8724-1"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>.add(id)
            else:
                root.dt[k]<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>.add(id)
        #root.print1()
        self.insert_traverse(root.dt[s<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>]<sup class="footnote" id="fnrev3daab284fc314f7382c115a8dd8e8724-2"><a href="#fn3daab284fc314f7382c115a8dd8e8724-2">1</a></sup>, s[1:], id)


    def insert(self, s, id):
        root = self.root
        self.insert_traverse(root, s, id)

    def traverse_compare(self, root, s1, n):
        if len(s1) == 0:
            return n
        if s1<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup> in root.dt:
            print(root.dt[s1<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>]<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>)
            return self.traverse_compare(root.dt[s1<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>]<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-2">1</a></sup>, s1[1:], root.dt[s1<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>]<sup class="footnote"><a href="#fn3daab284fc314f7382c115a8dd8e8724-1">0</a></sup>)
        return None

    def compare(self, s1):
        root = self.root
        return self.traverse_compare(root, s1, -1)



	<p>class Solution:
    def wordSubsets(self, A: List[str], B: List[str]) -&gt; List[str]:</p>

        bmax = [0] * 26
        for b in B:

            tempb = [0] * 26
            for i, c in enumerate(b):
                tempb[ord&#169; &#8211; ord(&#8216;a&#8217;)] += 1

            for i, m in enumerate(tempb):
                bmax[i] = max(bmax[i], tempb[i])


        res = []
        for a in A:
            amax = [0] * 26
            for i in a:
                amax[ord(i) &#8211; ord(&#8216;a&#8217;)] += 1
            t = True
            for x, y in zip(amax, bmax):
                if x &lt; y:
                    t = False
                    break
            if t:
                res.append(a)
        return res










        dt = {}
        t = Tree()
        arr = [0] * 26
        for idx, word in enumerate(words1):
            for k in word:
                if arr[ord(k) &#8211; ord(&#8216;a&#8217;)]  0:
                    arr[ord(k) - ord('a')] = {}
                if idx in arr[ord(k) - ord('a')]:
                    arr[ord(k) - ord('a')][idx] += 1
                else:
                    arr[ord(k) - ord('a')][idx] =  1
        m = [0] * len(words1)
        s = "".join(words2)
        for idx, word in enumerate(words2):
            arr1 = copy.deepcopy(arr)
            for k in word:
                if arr1[ord(k) - ord('a')] != 0:
                    for n in arr1[ord(k) - ord('a')].keys():
                        if arr1[ord(k) - ord('a')][n] > 0:
                            m[n] += 1
                            arr1[ord(k) - ord('a')][n] -= 1
        res = []
        s = "".join(words2)
        for idx, k in enumerate(m):
            if k  len(s):
                res.append(words1[idx])
        return res


        for idx, word in enumerate(words2):
            print(&#8220;&#8212;-&#8221;, t.compare(word))
            for k in t.compare(word) if  t.compare(word) != None else []:
                    m[k] += 1
        print(&#8220;m&#8221;, m)




        for idx, word in enumerate(words1):
            word = sorted(word)
            i = 0 
            j = 0
            while(i &lt; len(word)): # only 10 times
                j = i
                while(j &lt; len(word)): # only 10 times
                    if &#8220;&#8221;.join(word[i:j+1]) not in dt:
                        dt[&#8220;&#8221;.join(word[i:j+1])] = set()
                    if idx not in dt[&#8220;&#8221;.join(word[i:j+1])]:
                        dt[&#8220;&#8221;.join(word[i:j+1])].add(idx) 
                    j += 1
                i += 1






        for idx, word in enumerate(words2): #can happen m times
            word = &#8220;&#8221;.join(sorted(word))
            if word in dt:
                for k in dt[word]: # can happen n times
                    m[k] += 1
        res = []
        print(m)
        for idx, k in enumerate(m):
            if k == len(words2):
                res.append(words1[idx])

        return res


    &#8220;&#8221;&#8220;
    [&#8220;amazon&#8221;,&#8220;apple&#8221;,&#8220;facebook&#8221;,&#8220;google&#8221;,&#8220;leetcode&#8221;], words2 = [&#8220;ebo&#8221;,&#8220;ok&#8221;]
    &#8220;&#8221;&#8220;






        