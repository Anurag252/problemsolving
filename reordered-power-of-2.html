	<p>class Solution:
    def reorderedPowerOf2(self, n: int) -&gt; bool:
        l = list(str(n))
        res = []
        l.sort(key= lambda x : -int(x))
        print(l)
        k = 1
        while(k &lt;= int(&#8220;&#8221;.join(l)) ):
            b = list(str(k))
            b.sort(key= lambda x : -int(x))
            if &#8220;&#8221;.join(b) == &#8220;&#8221;.join(l):
                return True
            k *= 2
        return False</p>



        ln = len(str(n))

        def recurse(l):
            if len(l)  0:
                return []
            if len(l)  2:
                return [l<sup class="footnote" id="fnrev442659acc00241b29ec418c15172d16b-1"><a href="#fn442659acc00241b29ec418c15172d16b-1">0</a></sup> + l<sup class="footnote" id="fnrev442659acc00241b29ec418c15172d16b-2"><a href="#fn442659acc00241b29ec418c15172d16b-2">1</a></sup>, l<sup class="footnote"><a href="#fn442659acc00241b29ec418c15172d16b-2">1</a></sup> + l<sup class="footnote"><a href="#fn442659acc00241b29ec418c15172d16b-1">0</a></sup>]
            if len(l)  1:
                return [l[0]]
            res = set()
            for i,k in enumerate(l):
                a = recurse(l[:i])
                b = recurse(l[i+1:])
                print(a,b)
                if len(a)  0:
                    a.append(&#8220;&#8221;)
                if len(b) == 0:
                    b.append(&#8220;&#8221;)
                for m in a:
                    for n1 in b:
                        res.add(m + l[i] + n1)
                for m in b:
                    for n1 in a:
                        res.add(m + l[i] + n1)
            print(res)
            return res
        for k in recurse(l):

            if  ln == len(str(int(k))):
                print(k)
                return True
        return False



        