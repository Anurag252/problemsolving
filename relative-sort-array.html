	<p>/**
 * Note: The returned array must be malloced, assume caller calls free().
 */</p>

	<p>int compar (const void* p1, const void* p2);<br />
int  *secondarr ;<br />
int  secondarrSize ;</p>


	<p>int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {
    secondarr = malloc(arr2Size * sizeof(int*));
    secondarrSize = arr2Size;
    for (int i = 0 ; i < arr2Size; i ++){
        secondarr[i] = arr2[i];
    }
    int* new_arr = malloc(arr1Size * sizeof(int));
    for (int i = 0 ; i < arr1Size; i ++){
        new_arr[i] = arr1[i];
        printf(&#8220;%d  %d\n&#8221;, new_arr[i], i);
    }</p>

    qsort(new_arr, arr1Size , sizeof(int), compar);
    for (int i = 0 ; i < arr1Size; i ++){
        printf(&#8220;%d A %d\n&#8221;, new_arr[i], i);
    }
    free(secondarr);
     *returnSize = arr1Size;
    return new_arr ;
}

	<p>int compar (const void* p1, const void* p2) {</p>

    // find p1
    int i = 10000;
    int j = 10000;
    int* a = ((int*)p1);
    int* b = ((int*)p2);
    //printf(&#8220;%d  %d&#8221;, *a, *b);
    for (int k = 0 ; k < secondarrSize; k ++) {
        //printf(&#8220;%d AB\n&#8221;, secondarr[k]);
        if ((*a) == secondarr[k]) {
            i = k;
        }

        if ((*b)  secondarr[k]) {
            j = k;
        }
    }
    //printf("\n%d A %d\n", i, j);
    if (i  10000 &&amp; j == 10000) {
        if (*a > *b){
            return 1;
        } else {
            return -1;
        }
    }

    if (i == 10000) {
        return 1;
    }

    if (j == 10000) {
        return -1;
    }

    if (i > j) {
        return 1;
    }

    if (i < j) {
        return -1;
    }
    return 0;
}